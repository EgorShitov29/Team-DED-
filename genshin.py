# -*- coding: utf-8 -*-
"""Genshin.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1afLBc4TnwxwZittyTyQPDomz-2WWvC-L
"""

!pip install roboflow

from roboflow import Roboflow
rf = Roboflow(api_key="pHMudhkAwLuQk3CLKHQL")
project = rf.workspace("samokat").project("genshin-uus5a")
version = project.version(2)
dataset = version.download("yolov11")

!pip install ultralytics --no-deps

import pandas as pd
import os
import cv2
import shutil
from pathlib import Path
import random
from sklearn.model_selection import train_test_split
from ultralytics import YOLO
import matplotlib.pyplot as plt
import seaborn as sns

def visualize_random_samples(num_samples=3):
    train_image_dir = Path("Genshin-2/train/images")
    train_label_dir = Path("Genshin-2/train/labels")

    image_files = [f for f in train_image_dir.glob('*') if f.stem in common_files]
    samples = random.sample(image_files, min(num_samples, len(image_files)))

    fig, axes = plt.subplots(1, num_samples, figsize=(15, 5))

    for i, img_path in enumerate(samples):
        image = cv2.imread(str(img_path))
        image = cv2.cvtColor(image, cv2.COLOR_BGR2RGB)

        label_path = train_label_dir / f"{img_path.stem}.txt"
        h, w = image.shape[:2]

        with open(label_path, 'r') as f:
            for line in f.readlines():
                data = line.strip().split()
                if len(data) == 5:
                    class_id, x_center, y_center, bbox_w, bbox_h = map(float, data)

                    # Конвертируем из нормализованных координат в пиксельные
                    x_center *= w
                    y_center *= h
                    bbox_w *= w
                    bbox_h *= h

                    x1 = int(x_center - bbox_w / 2)
                    y1 = int(y_center - bbox_h / 2)
                    x2 = int(x_center + bbox_w / 2)
                    y2 = int(y_center + bbox_h / 2)

                    # Рисуем bounding box
                    cv2.rectangle(image, (x1, y1), (x2, y2), (255, 0, 0), 2)
                    cv2.putText(image, f'Class {int(class_id)}', (x1, y1-10),
                               cv2.FONT_HERSHEY_SIMPLEX, 0.5, (255, 0, 0), 2)

        if num_samples > 1:
            axes[i].imshow(image)
            axes[i].set_title(f'Sample {i+1}')
            axes[i].axis('off')
        else:
            axes.imshow(image)
            axes.set_title('Sample')
            axes.axis('off')

    plt.tight_layout()
    plt.show()

visualize_random_samples(3)

def analyze_classes():
    train_label_dir = Path("Genshin-2/train/labels")

    class_counts = {}
    bbox_stats = []

    for label_file in train_label_dir.glob('*.txt'):
        with open(label_file, 'r') as f:
            for line in f.readlines():
                data = line.strip().split()
                if len(data) == 5:
                    class_id = int(data[0])
                    class_counts[class_id] = class_counts.get(class_id, 0) + 1
                    bbox_stats.append([class_id] + [float(x) for x in data[1:]])

    # Создаем DataFrame для анализа
    df = pd.DataFrame(bbox_stats, columns=['class_id', 'x_center', 'y_center', 'width', 'height'])

    for class_id, count in sorted(class_counts.items()):
        print(f"Класс {class_id}: {count} объектов")

    # Визуализация распределения классов
    plt.figure(figsize=(12, 4))

    plt.subplot(1, 2, 1)
    sns.countplot(data=df, x='class_id')
    plt.title('Распределение классов')
    plt.xlabel('Class ID')
    plt.ylabel('Количество')

    plt.subplot(1, 2, 2)
    df[['width', 'height']].boxplot()
    plt.title('Размеры bounding boxes')
    plt.ylabel('Нормализованный размер')

    plt.tight_layout()
    plt.show()

    return df

df = analyze_classes()

def create_data_yaml():
    # Автоматически определяем количество классов
    train_label_dir = Path("Genshin-2/train/labels")
    class_ids = set()

    for label_file in train_label_dir.glob('*.txt'):
        with open(label_file, 'r') as f:
            for line in f.readlines():
                data = line.strip().split()
                if data:
                    class_ids.add(int(data[0]))

    nc = len(class_ids)

    # Создаем data.yaml
    yaml_content = f"""# Genshin Dataset
path: {Path('Genshin-2').absolute()}  # dataset root dir
train: train/images  # train images (relative to path)
val: valid/images    # validation images (relative to path)

# Classes
nc: {nc}  # number of classes
names: {list(range(nc))}
"""

    with open('Genshin-2/data.yaml', 'w') as f:
        f.write(yaml_content)

    print(yaml_content)

    return nc

num_classes = create_data_yaml()

def create_validation_split(val_ratio=0.2):
    train_image_dir = Path("Genshin-2/train/images")
    train_label_dir = Path("Genshin-2/train/labels")

    # Создаем папки для валидации
    valid_dir = Path("Genshin-2/valid")
    (valid_dir / "images").mkdir(parents=True, exist_ok=True)
    (valid_dir / "labels").mkdir(parents=True, exist_ok=True)

    # Получаем все соответствующие файлы
    valid_files = random.sample(list(common_files), int(len(common_files) * val_ratio))

    # Перемещаем файлы в валидационную выборку
    for file_stem in valid_files:
        # Изображения
        for ext in ['.jpg', '.png', '.jpeg']:
            src_img = train_image_dir / f"{file_stem}{ext}"
            if src_img.exists():
                dst_img = valid_dir / "images" / f"{file_stem}{ext}"
                shutil.move(str(src_img), str(dst_img))
                break

        # Метки
        src_label = train_label_dir / f"{file_stem}.txt"
        if src_label.exists():
            dst_label = valid_dir / "labels" / f"{file_stem}.txt"
            shutil.move(str(src_label), str(dst_label))

    print(f"Создана валидационная выборка: {len(valid_files)} файлов")

create_validation_split()

def train_yolo_model():
    model = YOLO('yolo11n.pt')

    results = model.train(
        data='Genshin-2/data.yaml',
        epochs=50,
        imgsz=640,
        batch=16,
        device='cuda',
        patience=10,
        save=True,
        verbose=True
    )

    return results

results = train_yolo_model()

model_result = pd.read_csv("/content/runs/detect/train/results.csv")

model_result

model_result.columns = model_result.columns.str.strip()

fig, axs = plt.subplots(nrows=5, ncols=2, figsize=(15, 15))

sns.lineplot(x='epoch', y='train/box_loss', data=model_result, ax=axs[0,0])
sns.lineplot(x='epoch', y='train/cls_loss', data=model_result, ax=axs[0,1])
sns.lineplot(x='epoch', y='train/dfl_loss', data=model_result, ax=axs[1,0])
sns.lineplot(x='epoch', y='metrics/precision(B)', data=model_result, ax=axs[1,1])
sns.lineplot(x='epoch', y='metrics/recall(B)', data=model_result, ax=axs[2,0])
sns.lineplot(x='epoch', y='metrics/mAP50(B)', data=model_result, ax=axs[2,1])
sns.lineplot(x='epoch', y='metrics/mAP50-95(B)', data=model_result, ax=axs[3,0])
sns.lineplot(x='epoch', y='val/box_loss', data=model_result, ax=axs[3,1])
sns.lineplot(x='epoch', y='val/cls_loss', data=model_result, ax=axs[4,0])
sns.lineplot(x='epoch', y='val/dfl_loss', data=model_result, ax=axs[4,1])

axs[0,0].set(title='Train Box Loss')
axs[0,1].set(title='Train Class Loss')
axs[1,0].set(title='Train DFL Loss')
axs[1,1].set(title='Metrics Precision (B)')
axs[2,0].set(title='Metrics Recall (B)')
axs[2,1].set(title='Metrics mAP50 (B)')
axs[3,0].set(title='Metrics mAP50-95 (B)')
axs[3,1].set(title='Validation Box Loss')
axs[4,0].set(title='Validation Class Loss')
axs[4,1].set(title='Validation DFL Loss')

plt.suptitle('Training Metrics and Loss', fontsize=24)
plt.subplots_adjust(top=0.8)
plt.tight_layout()
plt.show()

from PIL import Image

def test_on_images(model_path, test_images, conf=0.5):

    # Загружаем обученную модель
    model = YOLO(model_path)

    # Получаем все изображения для тестирования
    test_images = list(Path(test_images).glob('*.jpg')) + \
                  list(Path(test_images).glob('*.png')) + \
                  list(Path(test_images).glob('*.jpeg'))

    print(f"Тестируем на {len(test_images)} изображениях...")

    for r in results:
        im_array = r.plot()  # Рисуем bounding boxes
        im = Image.fromarray(im_array[..., ::-1])  # RGB PIL image

        plt.figure(figsize=(12, 8))
        plt.imshow(im)
        plt.title(f'Prediction: {Path(img_path).name}')
        plt.axis('off')
        plt.show()

        # Выводим информацию о детекциях
        print(f"Результаты для {img_path.name}:")
        if len(r.boxes) > 0:
            for box in r.boxes:
                cls = int(box.cls[0])
                conf = float(box.conf[0])
                print(f"  Класс {cls}: уверенность {conf:.3f}")
        else:
            print("  Объекты не обнаружены")


test_on_images('runs/detect/train/weights/best.pt', 'test_images')

